"""
This script will turn each of the xyz files in "molecules" into the C++ commands
to make said molecule in a source file
"""

import argparse
import os
import re

from generate_atomicinfo import parse_symbols
import helper_fxns as helpers

class Molecule:
    def __init__(self):
        self.carts = []
        self.atoms = []

    def add_atom(self, Z, carts):
        self.atoms.append(Z)
        for q in carts:
            self.carts.append(q)

    def __repr__(self):
        rv = ""
        for i, ai in enumerate(self.atoms):
            rv += ai + " "
            for j in range(3):
                rv += str(self.carts[i*3 + j]) + " "
            rv += "\n"
        return rv

    def cxxify(self, tab, f):
        for i, ai in enumerate(self.atoms):
            f.write(
"""{}mol.push_back(Atom{{mass_t(ptable_.get_atom({}).mass()), {}ul,
{}cart_t{{""".format(tab, ai, ai, tab + "     "))
            line = ""
            line = "{}cart_t{{".format(tab + "     ")
            line+="{}, {},".format(self.carts[i*3], self.carts[i*3+1])
            line +=" {}}},".format(self.carts[i*3+2])            
            f.write("{}, {},".format(self.carts[i*3], self.carts[i*3+1]))
            #Write third coordinate on newline to stay under 80 character column limit
            if(len(line)>80):
                f.write("\n{}{}".format(tab+tab, self.carts[i*3+2]))
            else:
                f.write(" {}".format(self.carts[i*3+2]))
            f.write("}});")
            if i != len(self.atoms) -1:
                f.write("\n")


def parse_file(file_name, sym2Z, ang2au):
    an_atom = r"^\s*(\S{1,2})((?:\s+-?\d*.\d+)+)"
    mol = Molecule()
    with open(file_name, 'r') as f:
        for l in f:
            is_match = re.match(an_atom, l)
            if is_match:
                (sym, str_carts) = is_match.groups()
                Z = sym2Z[sym.lower()]
                mol.add_atom(Z, [float(x)*ang2au for x in str_carts.split()])                
    return mol

def print_source(src_dir, mols):
    tab = "    "
    with open(os.path.join(src_dir, "nwx_molecule_manager_pimpl.cpp"), 'w') as f:
        f.write(
"""/*
 * This file was autogenerated by generate_mols.py. Any edits to it will be
 * lost the next time it is generated.
 */

#include \"libchemist/detail_/molecule_manager_pimpl.hpp\"

namespace libchemist::detail_ {

class HardCodedMolsPIMPL : public MoleculeManagerPIMPL {
public:
    using MoleculeManagerPIMPL::MoleculeManagerPIMPL;

protected:
    HardCodedMolsPIMPL(const HardCodedMolsPIMPL& rhs) = default;

private:
    unique_pimpl clone_() const override {
        using unique_me = std::unique_ptr<HardCodedMolsPIMPL>;
        return unique_me(new HardCodedMolsPIMPL(*this));
    }

    value_type at_(const key_type& name) const override {
        using cart_t = typename Atom::coord_type;
        using mass_t = typename Atom::mass_type;
        """)
        for mname, m in sorted(mols.items()):
            f.write("if(name == \"{}\") {{\n{}auto mol = Molecule();\n".format(mname, tab*3))
            m.cxxify(tab*3, f)
            f.write("\n{}return mol;\n{}}} else ".format(tab*3,tab*2))
        f.write("\nthrow std::out_of_range(\"Unknown molecule name\");\n")
        f.write(
"""    } // end at_
};    // end HardCodedMolsPIMPL

std::unique_ptr<MoleculeManagerPIMPL> nwx_default_mols() {
    return std::make_unique<HardCodedMolsPIMPL>();
}

} // namespace libchemist::detail_
""")


def main(args):
    """Entry point function to generate atomic density files.

    :param args: Command line argument namespace
    :type args: Namespace
    """

    extensions = [ ".xyz" ]

    # Create some paths
    my_dir    = os.path.dirname(os.path.realpath(__file__))
    name_file = os.path.join(my_dir, "physical_data", "ElementNames.txt")
    src_dir   = os.path.abspath(args.src_dir)
    test_dir  = os.path.abspath(args.test_dir)

    # Discover molecule files
    molecule_dir = os.path.abspath(args.molecule_dir)
    molecule_filepaths = helpers.find_files(
        molecule_dir, extensions, args.recursive
    )

    # Parse element information
    atoms = {}
    parse_symbols(name_file, atoms)

    sym2Z = {ai.sym.lower() : ai.Z for ai in atoms.values()}

    molecules = {}
    for extension in extensions:
        for filepath in molecule_filepaths[extension]:
            molecule = os.path.splitext(os.path.basename(filepath))[0]

            molecules[molecule] = parse_file(filepath, sym2Z, args.ang2au)
    
    print_source(src_dir, molecules)

def parse_args():
    """Parse command line arguments.

    :return: Values of command line arguments.
    :rtype: Namespace
    """
    
    parser = argparse.ArgumentParser()
    
    parser.add_argument('molecule_dir', type=str,
                        help="""Source directory for molecule files. If 
                             combined with the \"-r\" flag, this directory 
                             will be recursively searched for basis sets.""")
    parser.add_argument('src_dir', type=str,
                        help="Destination directory for generated source files.")
    parser.add_argument('test_dir', type=str,
                        help="Destination directory for generated unit tests.")

    parser.add_argument('--ang2au', type=float,
                        default=1.8897161646320724,
                        help="""Ratio of angstroms to atomic units. 
                             (Default: 1.8897161646320724)""")
    parser.add_argument('-r', '--recursive', action="store_true",
                        help="""Toggle on recursive search through the basis 
                             set source directory. Default OFF.""")

    return parser.parse_args()

if __name__ == "__main__":
    args = parse_args()

    main(args)
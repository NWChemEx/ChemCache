"""
This script will loop over a series of basis sets and write out a file that will
fill them in.  The format of the resulting basis sets is suitable for use with
the BasisSetExchange class
"""
import os
import fnmatch
import re
from generate_atomicinfo import parse_symbols

class Shell:
    def __init__(self, l):
        self.l = l
        self.exp=[]
        self.coefs=[]
        self.gen = 0
    def add_prim(self, exp, coefs):
        self.exp.append(exp)
        self.coefs.append(coefs)
        self.gen = max(len(coefs), self.gen)
    def cxxify(self, tab, f):
        for i in range(self.gen):
            l = self.l[i]
            f.write("{}rv.add_shell(ShellType::pure, {},\n".format(tab, l))
            cs = "std::vector<double>{"
            es = "std::vector<double>{"
            for j,ai in enumerate(self.exp):
                ci = self.coefs[j][i].replace('D', 'E').replace('E', 'e')
                ai_f = ai.replace('D', 'E').replace('E', 'e')
                cs += ci
                es += ai_f
                if j < len(self.exp) - 1:
                    cs += ','
                    es += ','
                else:
                    cs += '}'
                    es += '}'
            f.write("{}    {},\n".format(tab, cs))
            f.write("{}    {});\n".format(tab, es))

def print_pimpl_header(f):
    f.write(
"""
/*
 * This file is autogenerated by generate_basis.py.  Any modifications made in
 * this file will be lost next time generate_basis.py is run.
 */
       
#include \"libchemist/detail_/basis_set_manager_pimpl.hpp\"
#include \"libchemist/defaults/nwx_basis_list.hpp\"
        
namespace libchemist::detail_ {
       
class HardCodedBSMan : public BasisSetManagerPIMPL {
public:
    HardCodedBSMan() = default;
    using ao_basis_type = typename BasisSetManagerPIMPL::ao_basis_type;
protected:
    HardCodedBSMan(const HardCodedBSMan& rhs) = default;
private:
    std::unique_ptr<BasisSetManagerPIMPL> clone_() const override {
        return std::unique_ptr<HardCodedBSMan>(new HardCodedBSMan(*this));
    }
            
    ao_basis_type get_basis_(const std::string& name, 
                             size_type Z) const override {         
""")

def print_pimpl_footer(f):
    f.write(
"""throw std::out_of_range(\"Unrecognized basis name\");
    }//end get_basis_
};
        
std::unique_ptr<BasisSetManagerPIMPL> nwx_default_bs() {
    return std::make_unique<HardCodedBSMan>();
}
        
} // namespace libchemist::detail_
""")

def print_basis_header(f, bs_name):
    f.write(
"""/*
 * This file is autogenerated by generate_basis.py.  Any modifications made in
 * this file will be lost next time generate_basis.py is run.
 */
 
#include \"libchemist/defaults/nwx_basis_list.hpp\"
 
namespace libchemist::detail_ {{
 
Center<double> {}(std::size_t Z) {{
    switch(Z) {{         
""".format(bs_name))

def print_basis_list(f):
    f.write(
"""/*
 * This file is autogenerated by generate_basis.py.  Any modifications made in
 * this file will be lost next time generate_basis.py is run.
 */
         
#include \"libchemist/basis_set/basis_set.hpp\"
namespace libchemist::detail_ {
""")

def print_basis_footer(f):
    tab = "    "
    f.write(
"""{}default : {{ 
{}throw std::out_of_range(\"Basis not available for Z\");
{}}}\n{}}} // end switch\n
}} //end function
}} //end libchemist::detail_""".format(tab*2, tab*3, tab*2, tab))

def print_atom_basis(f, z, atom):
    tab = "    "
    f.write("{}case({}) : {{\n".format(tab*2, z))
    f.write("{}Center<double> rv(0.0, 0.0, 0.0);\n".format(tab*3))
    for s in atom:
        s.cxxify(tab*3,f)
    f.write("{}return rv;\n".format(tab*3))
    f.write("{}}} //End case\n".format(tab*2))

def sanitize_name(bs_name):
    temp = bs_name.replace("6-", "six_dash_")
    temp = temp.replace("3-", "three_dash_")
    temp = temp.replace("-", "_dash_")
    temp = temp.replace("-", "_dash_")
    temp = temp.replace("+", "_plus_")
    return temp

def desanitize_name(bs_name):
    temp = bs_name.replace("_star", "*")
    temp = temp.replace("-", "-")
    return temp

def write_bases(out_dir, bases):
    tab = "    "
    with open(os.path.join(out_dir,"nwx_basis_set_manager_pimpl.cpp"),'w') as f:
        print_pimpl_header(f)
        with open(os.path.join(out_dir, "nwx_basis_list.hpp"), 'w') as g:
            print_basis_list(g)
            f.write("{}".format(tab*2))
            for bs_name, bs in sorted(bases.items()):
                s_name = sanitize_name(bs_name)
                d_name = desanitize_name(bs_name)
                f.write("if(name == \"{}\") {{ ".format(d_name))
                f.write("return {}(Z); ".format(s_name))
                g.write("Center<double> {}(std::size_t Z);\n".format(s_name))
                bs_file_name = "{}.cpp".format(bs_name)
                bs_path = os.path.join(out_dir,"bases", bs_file_name)
                with open(bs_path, 'w') as h:
                    print_basis_header(h, s_name)
                    for z in sorted([int(x) for x in bs.keys()]):
                        print_atom_basis(h, z, bs[str(z)])
                    print_basis_footer(h)
                f.write("}}\n{}else ".format(tab*2))
            g.write("} //end namespace\n")
        print_pimpl_footer(f)

def parse_bases(basis_sets, sym2Z, l2num):
    new_atom = re.compile("^\s*\D{1,2}\s*0\s*$")
    new_shell = re.compile("^\s*[a-zA-Z]+\s*\d+\s*1.00\s*$")
    same_shell = re.compile("^\s*(?:-?\d+.\d+(?:(E|e|D|d)(\+|-)\d\d)*\s*)+")
    bases = {}
    for bs in basis_sets:
        bases[bs] = {}
        with open(os.path.join("basis_sets","default",bs+".gbs"),'r') as f:
            atom_z = 0
            for line in f:
                if re.search(new_atom, line):
                    atom_z = sym2Z[line.split()[0].lower()]
                    bases[bs][atom_z] = []
                elif re.search(new_shell, line):
                    ls = [ l2num(l.lower()) for l in line.split()[0]]
                    bases[bs][atom_z].append(Shell(ls))
                elif re.search(same_shell, line):
                    prim = line.split()
                    bases[bs][atom_z][-1].add_prim(prim[0], prim[1:])
    return bases

def main():

    basis_sets = [f.replace(".gbs","") for f in os.listdir("basis_sets/default") if os.path.isfile(os.path.join("basis_sets","default",f))]
    my_dir = os.path.dirname(os.path.realpath(__file__))
    out_dir = os.path.join(os.path.dirname(my_dir), "libchemist",
                           "defaults")
    atoms = parse_symbols(os.path.join(my_dir, "physical_data",
                                       "ElementNames.txt"), {})
    sym2Z = {ai.sym.lower() : ai.Z for ai in atoms.values()}
    l2num = lambda l: "spdfghijklmnoqrtuvwxyzabce".find(l.lower())
    bases = parse_bases(basis_sets, sym2Z, l2num)
    write_bases(out_dir, bases)


if __name__ == "__main__":
    main()

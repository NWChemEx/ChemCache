#!/usr/bin/env python3
# Copyright 2022 NWChemEx-Project
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
"""Reads files with atomic densities and write to cpp files.

Usage
-----

::

   usage: generate_densities.py [-h] [-r] [-a ATOMS_DIR] atomic_density_dir src_dir

   positional arguments:
     atomic_density_dir    Source directory for basis set files. If combined with the "-r" flag, this directory will be recursively searched for basis sets.
     src_dir               Destination directory for generated source files.
   
   options:
     -h, --help            show this help message and exit
     -r, --recursive       Toggle on recursive search through the basis set source directory. Default OFF.
     -a ATOMS_DIR, --atoms_dir ATOMS_DIR
                           The path to where ElementNames.txt can be found.
       
"""

import argparse
import os

from data_management.generate_atomicinfo import parse_symbols
import data_management.helper_fxns as helpers


def make_square_arr(a: list, spacer='\n'):
    n2 = len(a)
    n = int(n2**0.5)
    if n == 1:
        return '{' + f'{a[0]}' + '}'
    assert (n * n == n2)
    return f"{spacer}{{" + f"}},{spacer}{{".join(
        [", ".join(a[i * n:(i + 1) * n]) for i in range(n)]) + "}"


def _write_den_files(out_dir: str,
                     bs_name: str,
                     basis_set: dict,
                     tab: str = "    ") -> None:

    header_template = '''
#pragma once
#include <simde/simde.hpp>

namespace chemcache {{

template<typename FloatType>
simde::type::tensor {s_name}_atom_density_matrix_(
  simde::type::atomic_number Z, parallelzone::runtime::RuntimeView& rt) {{
    using shape_t     = tensorwrapper::shape::Smooth;
    using allocator_t = tensorwrapper::allocator::Eigen<FloatType>;
    using rank2_il_t  = typename allocator_t::rank2_il;

    allocator_t d_a(rt);
    switch(Z) {{
{cases}
        default: {{
            throw std::out_of_range("Atomic Density not available for Z");
        }}
    }}
}}

}} // namespace chemcache
'''

    source_template='''
#include "../density.hpp"
#include "{s_name}.hpp"

namespace chemcache {{

using atomic_den_pt = simde::AtomicDensityMatrixFromZ;
using udouble       = tensorwrapper::types::udouble;

static constexpr auto module_desc = R"(
{d_name} atomic density matrices
------------------------------

This module returns precomputed atomic densities in this basis set.
This module was autogenerated.
)";

MODULE_CTOR({s_name}_atom_density_matrix) {{
    description(module_desc);
    satisfies_property_type<atomic_den_pt>();
    add_input<bool>("With UQ?").set_default(false);
}}

MODULE_RUN({s_name}_atom_density_matrix) {{
    const auto& [Z]         = atomic_den_pt::unwrap_inputs(inputs);
    const auto is_uncertain = inputs.at("With UQ?").value<bool>();
    auto& rt                = this->get_runtime();

    simde::type::tensor result;
    if(is_uncertain) {{
        result = {s_name}_atom_density_matrix_<udouble>(Z, rt);
    }} else {{
        result = {s_name}_atom_density_matrix_<double>(Z, rt);
    }}
    auto rv = results();
    return atomic_den_pt::wrap_results(rv, result);
}}

}} // namespace chemcache
'''

    cases_template = '''{t}{t}case({Z}): {{
{t}{t}{t}shape_t shape{{{n}, {n}}};
{t}{t}{t}auto buffer = d_a.construct(rank2_il_t{{{values}}});
{t}{t}{t}return simde::type::tensor(shape, std::move(buffer));
{t}{t}}}'''

    d_name = helpers.desanitize_basis_name(bs_name)
    s_name = helpers.sanitize_basis_name(bs_name)
    cases = []
    for z in sorted([int(x) for x in basis_set.keys()]):
        values = make_square_arr(basis_set[str(z)].split(),
                                 spacer="\n" + tab * 4)
        n = int(len(basis_set[str(z)].split())**0.5)
        cases.append(
            cases_template.format(t=tab, Z=z, n=n, values=values))

    header_file = os.path.join(out_dir, s_name + ".hpp")
    with open(header_file, 'w') as fout:
        helpers.write_warning(fout, os.path.basename(__file__))
        fout.write(
            header_template.format(d_name=d_name,
                                   s_name=s_name,
                                   cases="\n".join(cases)))

    source_file = os.path.join(out_dir, s_name + ".cpp")
    with open(source_file, 'w') as fout:
        helpers.write_warning(fout, os.path.basename(__file__))
        fout.write(
            source_template.format(d_name=d_name,
                                   s_name=s_name))


def _write_densities(src_dir: str, bases: dict, tab="    ") -> None:
    """Writes basis set data to C++ files.

    :param src_dir: Source directory for source files.
    :type src_dir: str

    :param bases: Collection of basis sets parsed from files
    :type bases: dict

    :param tab: String representing a tab, defaults to "    "
        :type tab: str, optional
    """

    bases_template = """
#pragma once
#include <pluginplay/pluginplay.hpp>

namespace chemcache {{

// Module declarations will go here
DECLARE_MODULE(sad_density);
{declarations}

namespace density_mods {{

inline void set_defaults(pluginplay::ModuleManager& mm) {{
    // Default submodules within this subcollection will be set here
    {ao_submodules}
    {dm_submodules}
}}

inline void load_modules(pluginplay::ModuleManager& mm) {{
    // Modules will be added to the ModuleManager here
    {guess_modules}
    {density_modules}

    set_defaults(mm);
}}

}} // namespace density_mods

}} // namespace chemcache
"""

    declaration_template = "DECLARE_MODULE({}_atom_density_matrix);"
    ao_submod_template = 'mm.change_submod("{} SAD density", "Atomic Basis", "{} atomic basis");'
    dm_submod_template = 'mm.change_submod("{} SAD density", "Atomic Density", "{} atomic density matrix");'
    guess_mod_template = 'mm.add_module<sad_density>("{} SAD density");'
    den_mod_template = 'mm.add_module<{}_atom_density_matrix>("{} atomic density matrix");'

    ntab = "\n" + tab

    declarations = []
    ao_submodules = []
    dm_submodules = []
    guess_modules = []
    density_modules = []

    for bs_name, basis_set in sorted(bases.items()):
        d_name = helpers.desanitize_basis_name(bs_name)
        s_name = helpers.sanitize_basis_name(bs_name)

        basis_dir = os.path.join(src_dir, s_name)
        if not os.path.exists(basis_dir):
            os.mkdir(basis_dir)
        _write_den_files(basis_dir, bs_name, basis_set)

        declarations.append(declaration_template.format(s_name))
        ao_submodules.append(ao_submod_template.format(d_name, d_name))
        dm_submodules.append(dm_submod_template.format(d_name, d_name))
        guess_modules.append(guess_mod_template.format(d_name))
        density_modules.append(den_mod_template.format(s_name, d_name))


    bases_file = os.path.join(src_dir, "density.hpp")
    with open(bases_file, 'w') as fout:
        helpers.write_warning(fout, os.path.basename(__file__))
        fout.write(
            bases_template.format(declarations="\n".join(declarations),
                                  ao_submodules=ntab.join(ao_submodules),
                                  dm_submodules=ntab.join(dm_submodules),
                                  guess_modules=ntab.join(guess_modules),
                                  density_modules=ntab.join(density_modules)))


def _parse_densities_dat(filepaths, sym2Z) -> dict:
    """Parse atomic density files in .dat format. 

    :param filepaths: Full paths to atomic density files.
    :type filepaths: list of str

    :param sym2Z: Mapping from lowercased atomic symbols to atomic numbers
    :type sym2Z: dict

    :return: Collection of atomic densities sorted by basis set and element
    :rtype: dict
    """

    basis_sets = {}
    for filepath in filepaths:
        basis_set = os.path.splitext(os.path.basename(filepath))[0]

        basis_sets[basis_set] = {}

        with open(filepath, "r") as f:
            for line in f:
                line1 = line.strip().split()
                if ((len(line1) == 1) and (line1[0].isalpha())):
                    atom_z = sym2Z[line1[0].lower()]
                    guessDM = ''
                    line2 = f.readline().strip()
                    while (len(line2) > 0):
                        guessDM += (line2 + '\n')
                        line2 = f.readline().strip()
                basis_sets[basis_set][atom_z] = guessDM

    return basis_sets


def _parse_densities(filepaths, sym2Z, extension=".dat") -> dict:
    """Parse atomic density files of the specified format.

    :param filepaths: Full paths to atomic density files.
    :type filepaths: list of str

    :param sym2Z: Mapping from lowercased atomic symbols to atomic numbers
    :type sym2Z: dict

    :param extension: File format extension to parse, defaults to".dat"
    :type extension: str, optional

    :raises RuntimeError: Unsupported atomic density file format.

    :return: Collection of atomic densities sorted by basis set and element
    :rtype: dict
    """

    if (extension == ".dat"):
        return _parse_densities_dat(filepaths, sym2Z)
    else:
        raise RuntimeError(
            "Unsupported atomic density file format: {}".format(extension))


def main(args: argparse.Namespace) -> None:
    """Entry point function to generate atomic density files.

    :param args: Command line argument namespace
    :type args: argparse.Namespace
    """

    extensions = [".dat"]

    # Create some paths
    my_dir = os.path.dirname(os.path.realpath(__file__))
    src_dir = os.path.abspath(args.src_dir)
    name_file = os.path.abspath(
        os.path.join(args.atoms_dir, "ElementNames.txt"))

    # Discover atomic density files
    atomic_density_dir = os.path.abspath(args.atomic_density_dir)
    atomic_density_filepaths = helpers.find_files(atomic_density_dir,
                                                  extensions, args.recursive)

    # Parse element information
    atoms = {}
    parse_symbols(name_file, atoms)

    sym2Z = {ai.sym.lower(): ai.Z for ai in atoms.values()}

    # Gather atomic densities
    basis_sets = {}
    for extension in extensions:
        # NOTE: Extension order CAN matter!
        #       If the same basis set exists in atomic_densities
        #       and the new dict returned from parse_densities(), the
        #       atomic_densities version will be replaced by the
        #       parse_densities() version.
        basis_sets.update(
            _parse_densities(atomic_density_filepaths[extension], sym2Z,
                             extension))

    _write_densities(src_dir, basis_sets)


def parse_args() -> argparse.Namespace:
    """Parse command line arguments.

    :return: Values of command line arguments.
    :rtype: argparse.Namespace
    """

    parser = argparse.ArgumentParser(
        description="Reads files with atomic densities and write to cpp files."
    )

    parser.add_argument(
        'atomic_density_dir',
        type=str,
        help="""Source directory for basis set files. If combined
                             with the \"-r\" flag, this directory will be
                             recursively searched for basis sets.""")

    parser.add_argument(
        'src_dir',
        type=str,
        help="Destination directory for generated source files.")

    parser.add_argument('-r',
                        '--recursive',
                        action="store_true",
                        help="""Toggle on recursive search through the basis 
                             set source directory. Default OFF.""")

    parser.add_argument(
        "-a",
        "--atoms_dir",
        action="store",
        type=str,
        default="reference_data/physical_data",
        help="The path to where ElementNames.txt can be found.")

    return parser.parse_args()


if __name__ == "__main__":
    main(parse_args())
